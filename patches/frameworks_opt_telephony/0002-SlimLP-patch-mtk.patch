From bc4a2e6e825d72eeb8549f4d2c0af8de5a08ccf7 Mon Sep 17 00:00:00 2001
From: olegsvs <oleg.texet@gmail.com>
Date: Mon, 6 Jun 2016 20:11:13 -0400
Subject: [PATCH 2/2] SlimLP patch mtk

Change-Id: I525e469b4371acfdc953d0f13dc56934fc637a61
---
 .../android/internal/telephony/BaseCommands.java   |   2 +-
 .../android/internal/telephony/MediaTekRIL.java    |   5 +-
 src/java/com/android/internal/telephony/Phone.java |   2 +-
 .../com/android/internal/telephony/PhoneBase.java  |  74 +------
 src/java/com/android/internal/telephony/RIL.java   |  36 +--
 .../telephony/dataconnection/DcTracker.java        | 246 ++++++++++++++++-----
 .../telephony/dataconnection/DcTrackerBase.java    |  34 ++-
 .../android/internal/telephony/gsm/GSMPhone.java   |  23 ++
 .../android/internal/telephony/gsm/GsmMmiCode.java |  16 +-
 .../telephony/uicc/UiccCardApplication.java        |   1 +
 10 files changed, 278 insertions(+), 161 deletions(-)

diff --git a/src/java/com/android/internal/telephony/BaseCommands.java b/src/java/com/android/internal/telephony/BaseCommands.java
index 37dc7eb..e931d94 100644
--- a/src/java/com/android/internal/telephony/BaseCommands.java
+++ b/src/java/com/android/internal/telephony/BaseCommands.java
@@ -96,7 +96,7 @@ public abstract class BaseCommands implements CommandsInterface {
     protected Registrant mGsmBroadcastSmsRegistrant;
     protected Registrant mCatCcAlphaRegistrant;
     protected Registrant mSsRegistrant;
-
+    protected Registrant mCatSendSmsResultRegistrant;
     // MTK registrants
     protected RegistrantList mPhoneRatFamilyChangedRegistrants = new RegistrantList();
     protected RegistrantList mSessionChangedRegistrants = new RegistrantList();
diff --git a/src/java/com/android/internal/telephony/MediaTekRIL.java b/src/java/com/android/internal/telephony/MediaTekRIL.java
index 947fc3f..c08de98 100644
--- a/src/java/com/android/internal/telephony/MediaTekRIL.java
+++ b/src/java/com/android/internal/telephony/MediaTekRIL.java
@@ -993,8 +993,6 @@ public class MediaTekRIL extends RIL implements CommandsInterface {
             case RIL_UNSOL_SRVCC_STATE_NOTIFY: ret = responseInts(p); break;
             case RIL_UNSOL_HARDWARE_CONFIG_CHANGED: ret = responseHardwareConfig(p); break;
             // fxxk this conflicts with RIL_UNSOL_RADIO_CAPABILITY...
-            case RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE:
-                     ret = responseSetPhoneRatChanged(p); break;
             /* M: call control part start */
             case RIL_UNSOL_CALL_FORWARDING: ret = responseInts(p); break;
             case RIL_UNSOL_CRSS_NOTIFICATION: ret = responseCrssNotification(p); break;
@@ -1680,8 +1678,7 @@ public class MediaTekRIL extends RIL implements CommandsInterface {
             case RIL_UNSOL_ON_SS: return "UNSOL_ON_SS";
             case RIL_UNSOL_STK_CC_ALPHA_NOTIFY: return "UNSOL_STK_CC_ALPHA_NOTIFY";
             case RIL_UNSOL_STK_SEND_SMS_RESULT: return "RIL_UNSOL_STK_SEND_SMS_RESULT";
-            case RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE:
-                    return "RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE";
+
             /* M: call control part start */
             case RIL_UNSOL_CALL_FORWARDING: return "UNSOL_CALL_FORWARDING";
             case RIL_UNSOL_CRSS_NOTIFICATION: return "UNSOL_CRSS_NOTIFICATION";
diff --git a/src/java/com/android/internal/telephony/Phone.java b/src/java/com/android/internal/telephony/Phone.java
index ead5397..d4752fa 100644
--- a/src/java/com/android/internal/telephony/Phone.java
+++ b/src/java/com/android/internal/telephony/Phone.java
@@ -110,7 +110,7 @@ public interface Phone {
     static final String REASON_SINGLE_PDN_ARBITRATION = "SinglePdnArbitration";
     static final String REASON_DATA_SPECIFIC_DISABLED = "specificDisabled";
     static final String REASON_IWLAN_AVAILABLE = "iwlanAvailable";
-
+    static final String REASON_SIM_NOT_READY = "simNotReady";
     // Used for band mode selection methods
     static final int BM_UNSPECIFIED = 0; // selected by baseband automatically
     static final int BM_EURO_BAND   = 1; // GSM-900 / DCS-1800 / WCDMA-IMT-2000
diff --git a/src/java/com/android/internal/telephony/PhoneBase.java b/src/java/com/android/internal/telephony/PhoneBase.java
index a950116..2aa6bcb 100644
--- a/src/java/com/android/internal/telephony/PhoneBase.java
+++ b/src/java/com/android/internal/telephony/PhoneBase.java
@@ -2380,78 +2380,7 @@ public abstract class PhoneBase extends Handler implements Phone {
                 + this);
     }
 
-    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
-        pw.println("PhoneBase: subId=" + getSubId());
-        pw.println(" mPhoneId=" + mPhoneId);
-        pw.println(" mCi=" + mCi);
-        pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
-        pw.println(" mDcTracker=" + mDcTracker);
-        pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
-        pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
-        pw.println(" mCallRingDelay=" + mCallRingDelay);
-        pw.println(" mIsTheCurrentActivePhone=" + mIsTheCurrentActivePhone);
-        pw.println(" mIsVoiceCapable=" + mIsVoiceCapable);
-        pw.println(" mIccRecords=" + mIccRecords.get());
-        pw.println(" mUiccApplication=" + mUiccApplication.get());
-        pw.println(" mSmsStorageMonitor=" + mSmsStorageMonitor);
-        pw.println(" mSmsUsageMonitor=" + mSmsUsageMonitor);
-        pw.flush();
-        pw.println(" mLooper=" + mLooper);
-        pw.println(" mContext=" + mContext);
-        pw.println(" mNotifier=" + mNotifier);
-        pw.println(" mSimulatedRadioControl=" + mSimulatedRadioControl);
-        pw.println(" mUnitTestMode=" + mUnitTestMode);
-        pw.println(" isDnsCheckDisabled()=" + isDnsCheckDisabled());
-        pw.println(" getUnitTestMode()=" + getUnitTestMode());
-        pw.println(" getState()=" + getState());
-        pw.println(" getIccSerialNumber()=" + getIccSerialNumber());
-        pw.println(" getIccRecordsLoaded()=" + getIccRecordsLoaded());
-        pw.println(" getMessageWaitingIndicator()=" + getMessageWaitingIndicator());
-        pw.println(" getCallForwardingIndicator()=" + getCallForwardingIndicator());
-        pw.println(" isInEmergencyCall()=" + isInEmergencyCall());
-        pw.flush();
-        pw.println(" isInEcm()=" + isInEcm());
-        pw.println(" getPhoneName()=" + getPhoneName());
-        pw.println(" getPhoneType()=" + getPhoneType());
-        pw.println(" getVoiceMessageCount()=" + getVoiceMessageCount());
-        pw.println(" getActiveApnTypes()=" + getActiveApnTypes());
-        pw.println(" isDataConnectivityPossible()=" + isDataConnectivityPossible());
-        pw.println(" needsOtaServiceProvisioning=" + needsOtaServiceProvisioning());
-        pw.flush();
-        pw.println("++++++++++++++++++++++++++++++++");
-
-        try {
-            mDcTracker.dump(fd, pw, args);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        pw.flush();
-        pw.println("++++++++++++++++++++++++++++++++");
-
-        try {
-            getServiceStateTracker().dump(fd, pw, args);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        pw.flush();
-        pw.println("++++++++++++++++++++++++++++++++");
-
-        try {
-            getCallTracker().dump(fd, pw, args);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        pw.flush();
-        pw.println("++++++++++++++++++++++++++++++++");
-
-        try {
-            ((RIL)mCi).dump(fd, pw, args);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        pw.flush();
-        pw.println("++++++++++++++++++++++++++++++++");
-    }
+   
    // MTK additions
 
     @Override
@@ -2551,7 +2480,6 @@ public abstract class PhoneBase extends Handler implements Phone {
         pw.println("++++++++++++++++++++++++++++++++");
     }
 
-    @Override
     public void addParticipant(String dialString, Message onComplete) throws CallStateException {
         throw new CallStateException("addParticipant is not supported in this phone "
                 + this);
diff --git a/src/java/com/android/internal/telephony/RIL.java b/src/java/com/android/internal/telephony/RIL.java
index c8eb520..dfce64f 100644
--- a/src/java/com/android/internal/telephony/RIL.java
+++ b/src/java/com/android/internal/telephony/RIL.java
@@ -55,6 +55,7 @@ import android.telephony.SignalStrength;
 import android.telephony.SmsManager;
 import android.telephony.SmsMessage;
 import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import android.util.SparseArray;
 import android.view.Display;
@@ -78,7 +79,7 @@ import com.android.internal.telephony.dataconnection.DataCallResponse;
 import com.android.internal.telephony.dataconnection.DataProfile;
 import com.android.internal.telephony.TelephonyDevController;
 import com.android.internal.telephony.HardwareConfig;
-import android.telephony.TelephonyManager;
+
 import java.io.ByteArrayInputStream;
 import java.io.DataInputStream;
 import java.io.FileDescriptor;
@@ -289,7 +290,6 @@ public class RIL extends BaseCommands implements CommandsInterface {
     // divide the response array without prior knowledge of the number of elements.
     protected int mQANElements = 4;
 
-
     // MTK
     // save the status of screen
     private boolean isScreenOn = true;
@@ -507,10 +507,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
         return messageLength;
     }
 
-    class RILReceiver implements Runnable {
+    protected class RILReceiver implements Runnable {
         byte[] buffer;
 
-        RILReceiver() {
+        protected RILReceiver() {
             buffer = new byte[RIL_MAX_COMMAND_BYTES];
         }
 
@@ -683,7 +683,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
             riljLog("Not starting RILReceiver: wifi-only");
         } else {
             riljLog("Starting RILReceiver" + mInstanceId);
-            mReceiver = new RILReceiver();
+            mReceiver = createRILReceiver();
             mReceiverThread = new Thread(mReceiver, "RILReceiver" + mInstanceId);
             mReceiverThread.start();
 
@@ -697,6 +697,10 @@ public class RIL extends BaseCommands implements CommandsInterface {
         tdc.registerRIL(this);
     }
 
+    protected RILReceiver createRILReceiver() {
+        return new RILReceiver();
+    }
+
     //***** CommandsInterface implementation
 
     @Override
@@ -3388,7 +3392,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 }
                 break;
 
-              case RIL_UNSOL_RIL_CONNECTED: {
+            case RIL_UNSOL_RIL_CONNECTED: {
                 if (RILJ_LOGD) unsljLogRet(response, ret);
 
                 // Set ecc list before MO call
@@ -3731,7 +3735,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
         return new IccIoResult(sw1, sw2, s);
     }
 
-    private Object
+    protected Object
     responseICC_IOBase64(Parcel p) {
         int sw1, sw2;
         Message ret;
@@ -3911,6 +3915,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
 	      dataCall.suggestedRetryTime = p.readInt();
             dataCall.cid = p.readInt();
             dataCall.active = p.readInt();
+	    dataCall.mtu = p.readInt(); // fix for mobile data on MT6753 SoC
             dataCall.type = p.readString();
             dataCall.ifname = p.readString();
             if ((dataCall.status == DcFailCause.NONE.getErrorCode()) &&
@@ -3934,7 +3939,9 @@ public class RIL extends BaseCommands implements CommandsInterface {
                 if (!TextUtils.isEmpty(pcscf)) {
                     dataCall.pcscf = pcscf.split(" ");
                 }
-                dataCall.mtu = p.readInt();
+                if (version >= 11) {
+                    dataCall.mtu = p.readInt();
+                }
             }
         }
         return dataCall;
@@ -4223,7 +4230,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-    private ArrayList<ApnSetting> responseGetDataCallProfile(Parcel p) {
+    protected ArrayList<ApnSetting> responseGetDataCallProfile(Parcel p) {
         int nProfiles = p.readInt();
         if (RILJ_LOGD) riljLog("# data call profiles:" + nProfiles);
 
@@ -4312,7 +4319,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
         return response;
     }
 
-   private Object
+   protected Object
    responseHardwareConfig(Parcel p) {
       int num;
       ArrayList<HardwareConfig> response;
@@ -4410,7 +4417,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
             case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: return "SET_NETWORK_SELECTION_AUTOMATIC";
             case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: return "SET_NETWORK_SELECTION_MANUAL";
             case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : return "QUERY_AVAILABLE_NETWORKS ";
-			case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS : return "ABORT_QUERY_AVAILABLE_NETWORKS";
+            case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS : return "ABORT_QUERY_AVAILABLE_NETWORKS";
             case RIL_REQUEST_DTMF_START: return "DTMF_START";
             case RIL_REQUEST_DTMF_STOP: return "DTMF_STOP";
             case RIL_REQUEST_BASEBAND_VERSION: return "BASEBAND_VERSION";
@@ -4491,8 +4498,7 @@ public class RIL extends BaseCommands implements CommandsInterface {
             case RIL_REQUEST_GET_HARDWARE_CONFIG: return "GET_HARDWARE_CONFIG";
             case RIL_REQUEST_SIM_AUTHENTICATION: return "RIL_REQUEST_SIM_AUTHENTICATION";
             case RIL_REQUEST_SHUTDOWN: return "RIL_REQUEST_SHUTDOWN";
-case RIL_REQUEST_SET_PHONE_RAT_FAMILY: return "RIL_REQUEST_SET_PHONE_RAT_FAMILY";
-            case RIL_REQUEST_GET_PHONE_RAT_FAMILY: return "RIL_REQUEST_GET_PHONE_RAT_FAMILY";
+            case RIL_REQUEST_SET_PHONE_RAT_FAMILY: return "RIL_REQUEST_SET_PHONE_RAT_FAMILY";
 
             /* M: call control part start */
             case RIL_REQUEST_HANGUP_ALL: return "HANGUP_ALL";
@@ -4677,7 +4683,6 @@ case RIL_REQUEST_SET_PHONE_RAT_FAMILY: return "RIL_REQUEST_SET_PHONE_RAT_FAMILY"
             case RIL_UNSOL_SRVCC_STATE_NOTIFY:
                     return "UNSOL_SRVCC_STATE_NOTIFY";
             case RIL_UNSOL_HARDWARE_CONFIG_CHANGED: return "RIL_UNSOL_HARDWARE_CONFIG_CHANGED";
-case RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE: return "RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE";
             /* M: call control part start */
             case RIL_UNSOL_CALL_FORWARDING: return "UNSOL_CALL_FORWARDING";
             case RIL_UNSOL_CRSS_NOTIFICATION: return "UNSOL_CRSS_NOTIFICATION";
@@ -5324,7 +5329,8 @@ case RIL_UNSOL_SET_PHONE_RAT_FAMILY_COMPLETE: return "RIL_UNSOL_SET_PHONE_RAT_FA
 
         send(rr);
     }
- // MTK additions
+
+    // MTK additions
     //MTK-START Support Multi-Application
     @Override
     public void openIccApplication(int application, Message response) {
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
index 8b5e47a..aa5c1e6 100755
--- a/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTracker.java
@@ -87,7 +87,10 @@ import com.android.internal.telephony.uicc.UiccController;
 import com.android.internal.telephony.uicc.IccUtils;
 import com.android.internal.util.AsyncChannel;
 import com.android.internal.util.ArrayUtils;
+
+// MTK
 import com.mediatek.internal.telephony.dataconnection.FdManager;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.nio.ByteBuffer;
@@ -145,8 +148,6 @@ public final class DcTracker extends DcTrackerBase {
 
     private static final int PROVISIONING_SPINNER_TIMEOUT_MILLIS = 120 * 1000;
 
-    static final Uri PREFERAPN_NO_UPDATE_URI =
-                        Uri.parse("content://telephony/carriers/preferapn_no_update");
     static final Uri PREFERAPN_NO_UPDATE_URI_USING_SUBID =
                         Uri.parse("content://telephony/carriers/preferapn_no_update/subId/");
     static final String APN_ID = "apn_id";
@@ -170,7 +171,10 @@ public final class DcTracker extends DcTrackerBase {
             PhoneBase.PROPERTY_OOS_IS_DISCONNECT, true);
 
     private boolean mCanSetPreferApn = false;
+
     private AtomicBoolean mAttached = new AtomicBoolean(false);
+
+    /** Watches for changes to the APN db. */
     private ApnChangeObserver mApnObserver;
 
     private final String mProvisionActionName;
@@ -181,18 +185,40 @@ public final class DcTracker extends DcTrackerBase {
 
     public boolean mImsRegistrationState = false;
     private ApnContext mWaitCleanUpApnContext = null;
-
     private boolean mDeregistrationAlarmState = false;
     private PendingIntent mImsDeregistrationDelayIntent = null;
 
+    // MTK
     protected FdManager mFdMgr;
 
     /* IWLAN and WWAN co-exist flag */
     private boolean mWwanIwlanCoexistFlag = false;
-    private long mSubId;
+
+    private static final int EVENT_3GPP_RECORDS_LOADED = 100;
+
+    Handler mSimRecordsLoadedHandler = new Handler() {
+        @Override
+        public void handleMessage (Message msg) {
+            if (!mPhone.mIsTheCurrentActivePhone || mIsDisposed) {
+                loge("Sim handler handleMessage: Ignore msgs since phone is inactive");
+                return;
+            }
+
+            switch (msg.what) {
+                case EVENT_3GPP_RECORDS_LOADED:
+                    log("EVENT_3GPP_RECORDS_LOADED");
+                    onSimRecordsLoaded();
+                    break;
+            }
+        }
+    };
 
     private CdmaApnProfileTracker mOmhApt;
 
+    /* MMS Data Profile Device Override */
+    private static final int MMS_DATA_PROFILE = SystemProperties.getInt(
+            "ro.telephony.mms_data_profile", RILConstants.DATA_PROFILE_DEFAULT);
+
     //***** Constructor
     public DcTracker(PhoneBase p) {
         super(p);
@@ -218,6 +244,7 @@ public final class DcTracker extends DcTrackerBase {
         }
 
         mDataConnectionTracker = this;
+        registerForAllEvents();
         update();
         mApnObserver = new ApnChangeObserver();
         p.getContext().getContentResolver().registerContentObserver(
@@ -233,6 +260,7 @@ public final class DcTracker extends DcTrackerBase {
             mPhone.getContext().registerReceiver(mIntentReceiver, filter, null, mPhone);
         }
 
+        // MTK Fast Dormancy
         mFdMgr = FdManager.getInstance(p);
 
         // Add Emergency APN to APN setting list by default to support EPDN in sim absent cases
@@ -291,9 +319,6 @@ public final class DcTracker extends DcTrackerBase {
             mProvisioningSpinner = null;
         }
 
-        ConnectivityManager cm = (ConnectivityManager)mPhone.getContext().getSystemService(
-                Context.CONNECTIVITY_SERVICE);
-
         cleanUpAllConnections(true, null);
 
         super.dispose();
@@ -309,6 +334,7 @@ public final class DcTracker extends DcTrackerBase {
         if (mOmhApt != null) {
             mOmhApt.unregisterForModemProfileReady(this);
         }
+        unregisterForAllEvents();
 
         destroyDataConnections();
     }
@@ -321,6 +347,11 @@ public final class DcTracker extends DcTrackerBase {
             r.unregisterForRecordsLoaded(this);
             mIccRecords.set(null);
         }
+        r = mSimRecords.get();
+        if (r != null) {
+            r.unregisterForRecordsLoaded(mSimRecordsLoadedHandler);
+            mSimRecords.set(null);
+        }
         mPhone.mCi.unregisterForDataNetworkStateChanged(this);
         mPhone.getCallTracker().unregisterForVoiceCallEnded(this);
         mPhone.getCallTracker().unregisterForVoiceCallStarted(this);
@@ -355,6 +386,7 @@ public final class DcTracker extends DcTrackerBase {
             loge("isApnSupported: name=null");
             return false;
         }
+
         ApnContext apnContext = mApnContexts.get(name);
         if (apnContext == null) {
             loge("Request for unsupported mobile name: " + name);
@@ -732,11 +764,9 @@ public final class DcTracker extends DcTrackerBase {
             return true;
         }
 
-        if (mAllApnSettings != null) {
-            for (ApnSetting apn : mAllApnSettings) {
-                if (apn.canHandleType(type)) {
-                    return true;
-                }
+        for (ApnSetting apn : mAllApnSettings) {
+            if (apn.canHandleType(type)) {
+                return true;
             }
         }
         return false;
@@ -824,7 +854,7 @@ public final class DcTracker extends DcTrackerBase {
             notifyOffApnsOfAvailability(Phone.REASON_DATA_ATTACHED);
         }
         if (mAutoAttachOnCreationConfig) {
-            mAutoAttachOnCreation = true;
+            mAutoAttachOnCreation.set(true);
         }
         setupDataOnConnectableApns(Phone.REASON_DATA_ATTACHED);
     }
@@ -848,7 +878,7 @@ public final class DcTracker extends DcTrackerBase {
         IccRecords r = mIccRecords.get();
         boolean recordsLoaded = false;
         if (r != null) {
-			log("isDataAllowed mIccRecords=IccRecords {" + r.toString() + "}");
+            log("isDataAllowed mIccRecords=IccRecords {" + r.toString() + "}");
             recordsLoaded = r.getRecordsLoaded();
             if (DBG) log("isDataAllowed getRecordsLoaded=" + recordsLoaded);
         }
@@ -857,23 +887,31 @@ public final class DcTracker extends DcTrackerBase {
         int dataSub = SubscriptionManager.getDefaultDataSubId();
         boolean defaultDataSelected = SubscriptionManager.isValidSubscriptionId(dataSub);
 
+        boolean psRestricted = mIsPsRestricted;
+        boolean isSetNotification = mPhone.getContext().getResources().getBoolean(
+                com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
+        if (!isSetNotification) {
+            attachedState = true;
+            psRestricted = false;
+        }
+
         PhoneConstants.State state = PhoneConstants.State.IDLE;
         if (mPhone.getCallTracker() != null) {
             state = mPhone.getCallTracker().getState();
         }
         boolean allowed =
-                    (attachedState || mAutoAttachOnCreation) &&
+                    (attachedState || mAutoAttachOnCreation.get()) &&
                     (subscriptionFromNv || recordsLoaded) &&
                     (state == PhoneConstants.State.IDLE ||
                      mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) &&
                     internalDataEnabled &&
                     defaultDataSelected &&
                     (!mPhone.getServiceState().getDataRoaming() || getDataOnRoamingEnabled()) &&
-                    !mIsPsRestricted &&
+                    !psRestricted &&
                     desiredPowerState;
         if (!allowed && DBG) {
             String reason = "";
-            if (!(attachedState || mAutoAttachOnCreation)) {
+            if (!(attachedState || mAutoAttachOnCreation.get())) {
                 reason += " - Attached= " + attachedState;
             }
             if (!(subscriptionFromNv || recordsLoaded)) {
@@ -889,7 +927,7 @@ public final class DcTracker extends DcTrackerBase {
             if (mPhone.getServiceState().getDataRoaming() && !getDataOnRoamingEnabled()) {
                 reason += " - Roaming and data roaming not enabled";
             }
-            if (mIsPsRestricted) reason += " - mIsPsRestricted= true";
+            if (psRestricted) reason += " - mIsPsRestricted= true";
             if (!desiredPowerState) reason += " - desiredPowerState= false";
             if (DBG) log("isDataAllowed: not allowed due to" + reason);
         }
@@ -1318,10 +1356,9 @@ public final class DcTracker extends DcTrackerBase {
         return apn;
     }
 
-    private ArrayList<ApnSetting> createApnList(Cursor cursor) {
+    private ArrayList<ApnSetting> createApnList(Cursor cursor, IccRecords r) {
         ArrayList<ApnSetting> mnoApns = new ArrayList<ApnSetting>();
         ArrayList<ApnSetting> mvnoApns = new ArrayList<ApnSetting>();
-        IccRecords r = mIccRecords.get();
 
         if (cursor.moveToFirst()) {
             do {
@@ -1453,8 +1490,8 @@ public final class DcTracker extends DcTrackerBase {
         Message msg = obtainMessage();
         msg.what = DctConstants.EVENT_DATA_SETUP_COMPLETE;
         msg.obj = apnContext;
-        dcac.bringUp(apnContext, getInitialMaxRetry(), profileId, radioTech, mAutoAttachOnCreation,
-                msg);
+        dcac.bringUp(apnContext, getInitialMaxRetry(), profileId, radioTech, 
+                mAutoAttachOnCreation.get(), msg);
 
         if (DBG) log("setupData: initing!");
         return true;
@@ -1465,7 +1502,36 @@ public final class DcTracker extends DcTrackerBase {
      */
     private void onApnChanged() {
         if (DBG) log("onApnChanged: tryRestartDataConnections");
-        tryRestartDataConnections(true, Phone.REASON_APN_CHANGED);
+        setInitialAttachApn(create3gppApnsList(), mSimRecords.get());
+        tryRestartDataConnections(isApnCleanupNeeded(), Phone.REASON_APN_CHANGED);
+    }
+
+    private boolean isApnCleanupNeeded() {
+        boolean cleanUpApn = true;
+        for (ApnContext apnContext : mApnContexts.values()) {
+            if (DBG) log("cleanUpConnectionsOnUpdatedApns for " + apnContext);
+
+            ArrayList<ApnSetting> currentWaitingApns = apnContext.getWaitingApns();
+
+            if ((currentWaitingApns != null) && (!apnContext.isDisconnected())) {
+                int radioTech = mPhone.getServiceState().getRilDataRadioTechnology();
+                ArrayList<ApnSetting> waitingApns = buildWaitingApns(
+                        apnContext.getApnType(), radioTech);
+                if (DBG) log("new waitingApns:" + waitingApns);
+                if (waitingApns.size() == currentWaitingApns.size()) {
+                    cleanUpApn = false;
+                    for (int i = 0; i < waitingApns.size(); i++) {
+                        if (!currentWaitingApns.get(i).equals(waitingApns.get(i))) {
+                            if (DBG) log("new waiting apn is different at " + i);
+                            cleanUpApn = true;
+                            apnContext.setWaitingApns(waitingApns);
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        return cleanUpApn;
     }
 
     private void tryRestartDataConnections(boolean isCleanupNeeded, String reason) {
@@ -1482,7 +1548,6 @@ public final class DcTracker extends DcTrackerBase {
         // match the current operator.
         if (DBG) log("tryRestartDataConnections: createAllApnList and cleanUpAllConnections");
         createAllApnList();
-        setInitialAttachApn();
         if (isCleanupNeeded) {
             cleanUpAllConnections(!isDisconnected, reason);
         }
@@ -1704,6 +1769,14 @@ public final class DcTracker extends DcTrackerBase {
         setupDataOnConnectableApns(Phone.REASON_NV_READY);
     }
 
+    private void onSimNotReady() {
+        if (DBG) log("onSimNotReady");
+
+        cleanUpAllConnections(true, Phone.REASON_SIM_NOT_READY);
+        mAllApnSettings.clear();
+        mAutoAttachOnCreationConfig = false;
+    }
+
     @Override
     protected void onSetDependencyMet(String apnType, boolean met) {
         // don't allow users to tweak hipri to work around default dependency not met
@@ -2461,16 +2534,20 @@ public final class DcTracker extends DcTrackerBase {
      * @return operator numeric
      */
     private String getOperatorNumeric() {
-        String result;
+        String result = null;
+
         if (isNvSubscription()) {
             result = SystemProperties.get(CDMAPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC);
-            log("getOperatorNumberic - returning from NV: " + result);
-        } else {
+        }
+
+        if (TextUtils.isEmpty(result)) {
             IccRecords r = mIccRecords.get();
             result = (r != null) ? r.getOperatorNumeric() : "";
             log("getOperatorNumberic - returning from card: " + result);
+        } else {
+            log("getOperatorNumberic - returning from NV: " + result);
         }
-        if (result == null) result = "";
+
         return result;
     }
 
@@ -2506,7 +2583,7 @@ public final class DcTracker extends DcTrackerBase {
 
                 if (cursor != null) {
                     if (cursor.getCount() > 0) {
-                        mAllApnSettings = createApnList(cursor);
+                        mAllApnSettings.addAll(createApnList(cursor, mIccRecords.get()));
                     }
                     cursor.close();
                 }
@@ -2539,6 +2616,30 @@ public final class DcTracker extends DcTrackerBase {
         setDataProfilesAsNeeded();
     }
 
+    private ArrayList<ApnSetting> create3gppApnsList() {
+        ArrayList<ApnSetting>  apnsList = null;
+        IccRecords r = mSimRecords.get();
+        String operator = (r != null) ? r.getOperatorNumeric() : "";
+        if (!TextUtils.isEmpty(operator)) {
+            String selection = "numeric = '" + operator + "'";
+            // query only enabled apn.
+            // carrier_enabled : 1 means enabled apn, 0 disabled apn.
+            selection += " and carrier_enabled = 1";
+            if (DBG) log("create3gppApnList: selection=" + selection);
+
+            Cursor cursor = mPhone.getContext().getContentResolver().query(
+                    Telephony.Carriers.CONTENT_URI, null, selection, null, null);
+
+            if (cursor != null) {
+                if (cursor.getCount() > 0) {
+                    apnsList = createApnList(cursor, r);
+                }
+                cursor.close();
+            }
+        }
+        return apnsList;
+    }
+
     private void dedupeApnSettings() {
         ArrayList<ApnSetting> resultApns = new ArrayList<ApnSetting>();
 
@@ -2748,6 +2849,9 @@ public final class DcTracker extends DcTrackerBase {
             if (DBG) log("buildWaitingApns: usePreferred NotFoundException set to true");
             usePreferred = true;
         }
+        if (usePreferred) {
+            mPreferredApn = getPreferredApn();
+        }
         if (DBG) {
             log("buildWaitingApns: usePreferred=" + usePreferred
                     + " canSetPreferApn=" + mCanSetPreferApn
@@ -2777,7 +2881,7 @@ public final class DcTracker extends DcTrackerBase {
                 mPreferredApn = null;
             }
         }
-        if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
+        if (!mAllApnSettings.isEmpty()) {
             if (DBG) log("buildWaitingApns: mAllApnSettings=" + mAllApnSettings);
             for (ApnSetting apn : mAllApnSettings) {
                 if (DBG) log("buildWaitingApns: apn=" + apn);
@@ -2799,7 +2903,7 @@ public final class DcTracker extends DcTrackerBase {
                 }
             }
         } else {
-            loge("mAllApnSettings is empty!");
+            loge("mAllApnSettings is null!");
         }
         if (DBG) log("buildWaitingApns: X apnList=" + apnList);
         return apnList;
@@ -2827,7 +2931,7 @@ public final class DcTracker extends DcTrackerBase {
             return;
         }
 
-        String subId = Long.toString(mPhone.getSubId());
+        String subId = Integer.toString(mPhone.getSubId());
         Uri uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID, subId);
         log("setPreferredApn: delete");
         ContentResolver resolver = mPhone.getContext().getContentResolver();
@@ -2842,12 +2946,12 @@ public final class DcTracker extends DcTrackerBase {
     }
 
     private ApnSetting getPreferredApn() {
-        if (mAllApnSettings.isEmpty()) {
-            log("getPreferredApn: X not found mAllApnSettings.isEmpty");
+        if (mAllApnSettings == null || mAllApnSettings.isEmpty()) {
+            log("getPreferredApn: mAllApnSettings is " + ((mAllApnSettings == null)?"null":"empty"));
             return null;
         }
 
-        String subId = Long.toString(mPhone.getSubId());
+        String subId = Integer.toString(mPhone.getSubId());
         Uri uri = Uri.withAppendedPath(PREFERAPN_NO_UPDATE_URI_USING_SUBID, subId);
         Cursor cursor = mPhone.getContext().getContentResolver().query(
                 uri, new String[] { "_id", "name", "apn" },
@@ -2865,7 +2969,7 @@ public final class DcTracker extends DcTrackerBase {
             int pos;
             cursor.moveToFirst();
             pos = cursor.getInt(cursor.getColumnIndexOrThrow(Telephony.Carriers._ID));
-            for(ApnSetting p : mAllApnSettings) {
+            for (ApnSetting p : mAllApnSettings) {
                 log("getPreferredApn: apnSetting=" + p);
                 if (p.id == pos && p.canHandleType(mRequestedApnType)) {
                     log("getPreferredApn: X found apnSetting" + p);
@@ -3036,6 +3140,8 @@ public final class DcTracker extends DcTrackerBase {
             return RILConstants.DATA_PROFILE_DEFAULT; // DEFAULT for now
         } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_DUN)) {
             return RILConstants.DATA_PROFILE_TETHERED;
+        } else if (TextUtils.equals(apnType, PhoneConstants.APN_TYPE_MMS)) {
+            return MMS_DATA_PROFILE;
         } else {
             return RILConstants.DATA_PROFILE_DEFAULT;
         }
@@ -3073,6 +3179,8 @@ public final class DcTracker extends DcTrackerBase {
             return false;
         }
 
+        updateSimRecords();
+
         int dataRat = mPhone.getServiceState().getRilDataRadioTechnology();
         int appFamily = UiccController.getFamilyFromRadioTechnology(dataRat);
         IccRecords newIccRecords = getUiccRecords(appFamily);
@@ -3099,6 +3207,8 @@ public final class DcTracker extends DcTrackerBase {
                 mIccRecords.set(newIccRecords);
                 newIccRecords.registerForRecordsLoaded(
                         this, DctConstants.EVENT_RECORDS_LOADED, null);
+            } else {
+                onSimNotReady();
             }
             // Records changed -> return true
             result = true;
@@ -3106,10 +3216,41 @@ public final class DcTracker extends DcTrackerBase {
         return result;
     }
 
+    /**
+     * This function updates mSimRecords reference to track the current 3GPP icc records.
+     * mSimRecords is used to populate the initial attach apn for the ICC card.
+     */
+    private void updateSimRecords() {
+        if (mUiccController == null ) {
+            return;
+        }
+
+        IccRecords newSimRecords = getUiccRecords(UiccController.APP_FAM_3GPP);
+        log("updateSimRecords: newSimRecords = " + newSimRecords);
+
+        IccRecords r = mSimRecords.get();
+        if (r != newSimRecords) {
+            if (r != null) {
+                log("Removing stale sim objects.");
+                r.unregisterForRecordsLoaded(mSimRecordsLoadedHandler);
+                mSimRecords.set(null);
+            }
+            if (newSimRecords != null) {
+                log("New sim records found");
+                mSimRecords.set(newSimRecords);
+                newSimRecords.registerForRecordsLoaded(
+                        mSimRecordsLoadedHandler, EVENT_3GPP_RECORDS_LOADED, null);
+            }
+        }
+    }
+
+    private void onSimRecordsLoaded() {
+        setInitialAttachApn(create3gppApnsList(), mSimRecords.get());
+    }
+
     public void update() {
         log("update sub = " + mPhone.getSubId());
         log("update(): Active DDS, register for all events now!");
-        registerForAllEvents();
         onUpdateIcc();
 
         mUserDataEnabled = Settings.Global.getInt(mPhone.getContext().getContentResolver(),
@@ -3335,24 +3476,21 @@ public final class DcTracker extends DcTrackerBase {
      * Add the Emergency APN settings to APN settings list
      */
     private void addEmergencyApnSetting() {
-        if(mEmergencyApn != null) {
-            if(mAllApnSettings == null) {
-                mAllApnSettings = new ArrayList<ApnSetting>();
-            } else {
-                boolean hasEmergencyApn = false;
-                for (ApnSetting apn : mAllApnSettings) {
-                    if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_EMERGENCY)) {
-                        hasEmergencyApn = true;
-                        break;
-                    }
-                }
-
-                if(hasEmergencyApn == false) {
-                    mAllApnSettings.add(mEmergencyApn);
-                } else {
-                    log("addEmergencyApnSetting - E-APN setting is already present");
-                }
+        if (mEmergencyApn == null) {
+            return;
+        }
+        boolean hasEmergencyApn = false;
+        for (ApnSetting apn : mAllApnSettings) {
+            if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_EMERGENCY)) {
+                hasEmergencyApn = true;
+                break;
             }
         }
+
+        if (!hasEmergencyApn) {
+            mAllApnSettings.add(mEmergencyApn);
+        } else {
+            log("addEmergencyApnSetting - E-APN setting is already present");
+        }
     }
 }
diff --git a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
index a513a54..816aa81 100644
--- a/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
+++ b/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java
@@ -68,8 +68,10 @@ import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.PriorityQueue;
@@ -195,6 +197,8 @@ public abstract class DcTrackerBase extends Handler {
     protected PhoneBase mPhone;
     protected UiccController mUiccController;
     protected AtomicReference<IccRecords> mIccRecords = new AtomicReference<IccRecords>();
+    // 3GPP records to use for LTE initial attach apn
+    protected AtomicReference<IccRecords> mSimRecords = new AtomicReference<IccRecords>();
     protected DctConstants.Activity mActivity = DctConstants.Activity.NONE;
     protected DctConstants.State mState = DctConstants.State.IDLE;
     protected Handler mDataConnectionTracker = null;
@@ -234,7 +238,7 @@ public abstract class DcTrackerBase extends Handler {
 
     // When false we will not auto attach and manually attaching is required.
     protected boolean mAutoAttachOnCreationConfig = false;
-    protected boolean mAutoAttachOnCreation = false;
+    protected AtomicBoolean mAutoAttachOnCreation = new AtomicBoolean(false);;
 
     // State of screen
     // (TODO: Reconsider tying directly to screen, maybe this is
@@ -274,7 +278,7 @@ public abstract class DcTrackerBase extends Handler {
     protected ApnSetting mActiveApn;
 
     /** allApns holds all apns */
-    protected ArrayList<ApnSetting> mAllApnSettings = new ArrayList<ApnSetting>();
+    protected final ArrayList<ApnSetting> mAllApnSettings = new ArrayList<ApnSetting>();
 
     /** preferred apn */
     protected ApnSetting mPreferredApn = null;
@@ -607,7 +611,7 @@ public abstract class DcTrackerBase extends Handler {
         }
 
         SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mPhone.getContext());
-        mAutoAttachOnCreation = sp.getBoolean(PhoneBase.DATA_DISABLED_ON_BOOT_KEY, false);
+        mAutoAttachOnCreation.set(sp.getBoolean(PhoneBase.DATA_DISABLED_ON_BOOT_KEY, false));
 
         mSubscriptionManager = SubscriptionManager.from(mPhone.getContext());
         mSubscriptionManager
@@ -638,7 +642,7 @@ public abstract class DcTrackerBase extends Handler {
         mDcTesterFailBringUpAll.dispose();
     }
 
-    public long getSubId() {
+    public int getSubId() {
         return mPhone.getSubId();
     }
 
@@ -773,6 +777,7 @@ public abstract class DcTrackerBase extends Handler {
     public void setDataOnRoamingEnabled(boolean enabled) {
         if (getDataOnRoamingEnabled() != enabled) {
             final ContentResolver resolver = mPhone.getContext().getContentResolver();
+
             Settings.Global.putInt(resolver,
                     Settings.Global.DATA_ROAMING + mPhone.getPhoneId(), enabled ? 1 : 0);
             // will trigger handleDataOnRoamingChange() through observer
@@ -1796,19 +1801,20 @@ public abstract class DcTrackerBase extends Handler {
         startDataStallAlarm(DATA_STALL_NOT_SUSPECTED);
     }
 
-    protected void setInitialAttachApn() {
+    protected void setInitialAttachApn(ArrayList <ApnSetting> apnList, IccRecords r) {
         ApnSetting iaApnSetting = null;
         ApnSetting defaultApnSetting = null;
         ApnSetting firstApnSetting = null;
+        String operator = (r != null) ? r.getOperatorNumeric(): "";
 
         log("setInitialApn: E operator=" + operator + " mPreferredApn=" + mPreferredApn);
 
-        if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
-            firstApnSetting = mAllApnSettings.get(0);
+        if (apnList != null && !apnList.isEmpty()) {
+            firstApnSetting = apnList.get(0);
             log("setInitialApn: firstApnSetting=" + firstApnSetting);
 
             // Search for Initial APN setting and the first apn that can handle default
-            for (ApnSetting apn : mAllApnSettings) {
+            for (ApnSetting apn : apnList) {
                 // Can't use apn.canHandleType(), as that returns true for APNs that have no type.
                 if (ArrayUtils.contains(apn.types, PhoneConstants.APN_TYPE_IA) &&
                         apn.carrierEnabled) {
@@ -1835,7 +1841,7 @@ public abstract class DcTrackerBase extends Handler {
         if (iaApnSetting != null) {
             if (DBG) log("setInitialAttachApn: using iaApnSetting");
             initialAttachApnSetting = iaApnSetting;
-        } else if (mPreferredApn != null) {
+        } else if (mPreferredApn != null && Objects.equals(mPreferredApn.numeric, operator)) {
             if (DBG) log("setInitialAttachApn: using mPreferredApn");
             initialAttachApnSetting = mPreferredApn;
         } else if (defaultApnSetting != null) {
@@ -1859,6 +1865,10 @@ public abstract class DcTrackerBase extends Handler {
         }
     }
 
+    protected void setInitialAttachApn() {
+        setInitialAttachApn(mAllApnSettings, mIccRecords.get());
+    }
+
     protected void setDataProfilesAsNeeded() {
         if (DBG) log("setDataProfilesAsNeeded");
         if (mAllApnSettings != null && !mAllApnSettings.isEmpty()) {
@@ -1947,6 +1957,10 @@ public abstract class DcTrackerBase extends Handler {
         sendMessage(msg);
     }
 
+    public boolean getAutoAttachOnCreation() {
+        return mAutoAttachOnCreation.get();
+    }
+
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         pw.println("DcTrackerBase:");
         pw.println(" RADIO_TESTS=" + RADIO_TESTS);
@@ -1977,7 +1991,7 @@ public abstract class DcTrackerBase extends Handler {
         pw.println(" mIsWifiConnected=" + mIsWifiConnected);
         pw.println(" mReconnectIntent=" + mReconnectIntent);
         pw.println(" mCidActive=" + mCidActive);
-        pw.println(" mAutoAttachOnCreation=" + mAutoAttachOnCreation);
+        pw.println(" mAutoAttachOnCreation=" + mAutoAttachOnCreation.get());
         pw.println(" mIsScreenOn=" + mIsScreenOn);
         pw.println(" mUniqueIdGenerator=" + mUniqueIdGenerator);
         pw.flush();
diff --git a/src/java/com/android/internal/telephony/gsm/GSMPhone.java b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
index 99f4bb9..ba26872 100644
--- a/src/java/com/android/internal/telephony/gsm/GSMPhone.java
+++ b/src/java/com/android/internal/telephony/gsm/GSMPhone.java
@@ -1461,6 +1461,28 @@ public class GSMPhone extends PhoneBase {
         mDcTracker.setDataEnabled(enable);
     }
 
+     /**
+     * Removes the given MMI from the pending list and notifies
+     * registrants that it is complete.
+     * @param mmi MMI that is done
+     */
+    /*package*/ void
+    onMMIDone(GsmMmiCode mmi) {
+        /* Only notify complete if it's on the pending list.
+         * Otherwise, it's already been handled (eg, previously canceled).
+         * The exception is cancellation of an incoming USSD-REQUEST, which is
+         * not on the list.
+         */
+
+        /* M: SS part */
+        Rlog.d(LOG_TAG, "mPendingMMIs.remove(mmi) - " + mmi);
+        /* M: SS part end */
+        if (mPendingMMIs.remove(mmi) || mmi.isUssdRequest() || mmi.isSsInfo()) {
+            mMmiCompleteRegistrants.notifyRegistrants(
+                new AsyncResult(null, mmi, null));
+        }
+    }
+
     /**
      * Removes the given MMI from the pending list and notifies
      * registrants that it is complete.
@@ -1482,6 +1504,7 @@ public class GSMPhone extends PhoneBase {
         }
     }
 
+
     /**
      * Used to check if Call Forwarding status is present on sim card. If not, a message is
      * sent so we can check if the CF status is stored as a Shared Preference.
diff --git a/src/java/com/android/internal/telephony/gsm/GsmMmiCode.java b/src/java/com/android/internal/telephony/gsm/GsmMmiCode.java
index 11998c8..1680fe7 100644
--- a/src/java/com/android/internal/telephony/gsm/GsmMmiCode.java
+++ b/src/java/com/android/internal/telephony/gsm/GsmMmiCode.java
@@ -36,6 +36,7 @@ import android.telephony.Rlog;
 
 import static com.android.internal.telephony.CommandsInterface.*;
 import com.android.internal.telephony.gsm.SsData;
+import android.util.Log;
 
 import java.util.regex.Pattern;
 import java.util.regex.Matcher;
@@ -73,6 +74,7 @@ public final class GsmMmiCode extends Handler implements MmiCode {
     //Called line presentation
     static final String SC_CLIP    = "30";
     static final String SC_CLIR    = "31";
+    static final int SINGLE_DIGIT_DIALED =    1;
 
     // Call Forwarding
     static final String SC_CFU     = "21";
@@ -1183,17 +1185,25 @@ public final class GsmMmiCode extends Handler implements MmiCode {
                 ar = (AsyncResult) (msg.obj);
                 onQueryComplete(ar);
             break;
-
             case EVENT_USSD_COMPLETE:
                 ar = (AsyncResult) (msg.obj);
 
                 if (ar.exception != null) {
                     mState = State.FAILED;
-                    mMessage = getErrorMessage(ar);
-
+                    // suppress error pop-up for single dialed digits
+                    if (mDialingNumber != null &&
+                                mDialingNumber.length() == SINGLE_DIGIT_DIALED) {
+                        Log.w(
+                            LOG_TAG,
+                            mContext.getText(com.android.internal.R.string.mmiError).toString()
+                            );
+                    } else {
+                        mMessage = getErrorMessage(ar);
+                    }
                     mPhone.onMMIDone(this);
                 }
 
+
                 // Note that unlike most everything else, the USSD complete
                 // response does not complete this MMI code...we wait for
                 // an unsolicited USSD "Notify" or "Request".
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
index d646be2..ede4842 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
@@ -23,6 +23,7 @@ import android.os.Message;
 import android.os.Registrant;
 import android.os.RegistrantList;
 import android.telephony.Rlog;
+import android.os.SystemProperties;
 
 import com.android.internal.telephony.CommandsInterface;
 import com.android.internal.telephony.PhoneConstants;
-- 
1.9.1

